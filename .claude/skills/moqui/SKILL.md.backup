---
name: moqui_complete
description: Complete Moqui Ecosystem documentation - framework, applications, business artifacts, and comprehensive development guide
---

# Moqui_Complete Skill

Comprehensive assistance with moqui_complete development, generated from official documentation.

## When to Use This Skill

This skill should be triggered when:
- Working with moqui_complete
- Asking about moqui_complete features or APIs
- Implementing moqui_complete solutions
- Debugging moqui_complete code
- Learning moqui_complete best practices

## Quick Reference

### Common Patterns

**Pattern 1:** Ecosystem Framework Business Artifacts Applications Add ons Forum Service Providers Issues & Tasks My Account My Requests (Issues) HiveMind PM Documentation Moqui Ecosystem Moqui Framework Mantle Business Artifacts Applications API JavaDoc Search Try the applications demo! Try POP Shop eCommerce! Comments? Questions? Get Involved? Join the Forum Wiki Spaces Mantle Business Artifacts Moqui Applications Moqui Community Moqui Framework Page Tree Moqui Framework All Pages Notification and WebSocket The Notification functionality in Moqui Framework is a user and topic based publish/subscribe tool that can be used to push notifications to server code by direct topic subscription or client applications by WebSocket. Other interfaces for client applications could be built for anything you'd like but the current OOTB implementation for this is WebSocket based and meant for notifications, screen pops, etc in web-based client applications. NotificationMessage (server side) The NotificationMessage interface in the Moqui Framework API is the primary object for generating notifications for one or more users and with a specific topic. The topic for a Notification is an arbitrary string identifier to distinguish different types of messages so that listeners (server side or client side) can listen for just the topics they know how to handle. To generate a message first use the ExecutionContext.makeNotificationMessage() method which returns a NotificationMessage object. On that object call methods as needed to set the topic, title, type (info, success, warning, danger), message (Map or JSON body), and specify the user(s) and/or user groups that should receive the notification. For example: ec.makeNotificationMessage().topic("TestTopic").type("info").title("Test notification message") .message(messageMapOrJsonString).userGroupId("ALL_USERS").send() In this example a notification is sent to all users (via the Moqui automatic 'ALL_USERS' userGroupId) with the topic "TestTopic" and a message body in a Map or String object called 'messageMapOrJsonString'. TODO: reference for all methods on NotificationMessage interface NotificationTopic Entity TODO general description, use to configure defaults for a topic as alternative to setting options in code TODO: reference for all fields on NotificationTopic entity NotificationMessageListener TODO ec.factory.registerNotificationMessageListener() Code References ExecutionContext NotificationMessage NotificationMessageImpl NotificationMessageListener NotificationClient (JS client side) TODO general description and how it works TODO example JavaScript to use for displaying a growl style notification TODO example JavaScript to use for custom client handling (screen pop, modify state, etc) Code References MoquiLib.js WebrootVue.js NotificationWebSocketListener NotificationEndpoint

```
ec.makeNotificationMessage().topic("TestTopic").type("info").title("Test notification message")
        .message(messageMapOrJsonString).userGroupId("ALL_USERS").send()
```

**Pattern 2:** Ecosystem Framework Business Artifacts Applications Add ons Forum Service Providers Issues & Tasks My Account My Requests (Issues) HiveMind PM Documentation Moqui Ecosystem Moqui Framework Mantle Business Artifacts Applications API JavaDoc Search Try the applications demo! Try POP Shop eCommerce! Comments? Questions? Get Involved? Join the Forum Wiki Spaces Mantle Business Artifacts Moqui Applications Moqui Community Moqui Framework Page Tree Moqui Framework All Pages Service Implementation Some service types have local implementations while others have no implementation (interface) or the service definition is a proxy for something else and the location refers to an external implementation (remote-xml-rpc,* remote-json-rpc*, and camel). The remote and Apache Camel types are described in detail in the System Interfaces section. Service Scripts Inline Actions Java Methods Entity Auto Services Add Your Own Service Runner Service Scripts A script is generally the best way to implement a service, unless an automatic implementation for entity CrUD operations will do. Scripts are reloaded automatically when their cache entry is clear, and in development mode these caches expire in a short time by default to get updates automatically. Scripts can run very efficiently, especially Groovy scripts which compile to Java classes at runtime and are cached in their compiled form so they can be run quickly. XML Actions scripts are transformed into a Groovy script (see the* XmlActions.groovy.ftl* file for details) and then compiled and cached, so have a performance profile just like a plain Groovy script. Any script that the Resource Facade can run can be used as a service implementation. See the Rendering Templates and Running Scripts section for details. In summary the scripts supported by default are Groovy, XML Actions, and JavaScript. Any scripting language can be supported through the javax.script or Moqui-specific interfaces. Here is an example of a service implemented with a Groovy script, defined in the org.moqui.impl.EmailServices.xml file: <service verb="send" noun="Email" type="script" location="classpath://org/moqui/impl/sendEmailTemplate.groovy" allow-remote="false"> <implements service="org.moqui.EmailServices.send#EmailTemplate"/> </service> In this case the location is a classpath location, but any location supported by the Resource Facade can be used. See the Resource Locations section for details on how to refer to files within components, in the local file system, or even at general URLs. At the beginning of a script all of the input parameters passed into the service, or set through defaults in the service definition, will be in the context as fields available for use in the script. As with other artifacts in Moqui there is also an ec field with the current ExecutionContext object. Note that the script has a context isolated from whatever called it using the ContextStack.pushContext() and popContext() methods meaning not only do fields created in the context not persist after the service is run, but the service does not have access to the context of whatever called it even though it may be running locally and within the same ExecutionContext as whatever called it. For convenience there is a result field in the context that is of type Map<String, Object>. You can put output parameters in this Map to return them, but doing so is not necessary. After the script is run the script service runner looks for all output parameters defined on the service in the context and adds them to the results. The script can also return (evaluate to) a Map object to return results. Inline Actions The service definition example near the beginning of this section shows a service with the default service type, inline. In this case the implementation is in the service.actions element, which contains a XML Actions script. It is treated just like an external script referred to by the service location but for simplicity and to reduce the number of files to work with it can be inline in the service definition. Java Methods A service implementation can also be a Java method, either a class (static) method or an object method. If the method is not static then the service runner creates a new instance of the object using the default (no arguments) constructor. The method must take a single ExecutionContext argument and return a Map<String, Object>, so the signature of the method would be something like: Map<String, Object> myService(ExecutionContext ec) Entity Auto Services With entity-auto type services you don’t have to implement the service, the implementation is automatic based on the verb and noun attribute values. The verb can be create, update, delete, or store (which is a create if the record does not exist, update if it does). The noun is an entity name, either a full name with the package or just the simple entity name with no package. Entity Auto services can be implicitly (automatically) defined by just calling a service named like ${verb}#${noun} with no path (package or filename). For example: ec.service.sync().name("create", "moqui.example.Example").parameters([exampleName:’Test Example’]).call() When you define a service and use the entity-auto implementation you can specify which input parameters to use (must match fields on the entity), whether they are required, default values, etc. When you use an implicitly defined entity auto service it determines the behavior based on what is passed into the service call. In the example above there is no exampleId parameter passed in, and that is the primary key field of the moqui.example.Example entity, so it automatically generates a sequenced ID for the field, and returns it as an output parameter. For create operations in addition to automatically generating missing primary sequenced IDs it will also generate a secondary sequenced ID if the entity has a 2-part primary key and one is specified while the other is missing. There is also special behavior if there is a fromDate primary key field that is not passed in, it will use the now Timestamp to populate it. The pattern for is update to pass in all primary key fields (this is required) and any non-PK field desired. There is special behavior for update as well. If the entity has a statusId field and a statusId parameter is passed in that is different then it automatically returns the original (DB) value in the oldStatusId output parameter. Whenever the entity has a statusId field it also returns a statusChanged boolean parameter which is true if the parameter is different from the original (DB) value, false otherwise. Entity auto services also enforce valid status transitions by checking for the existing of a matching moqui.basic.StatusFlowTransition record. If no valid transition is found it will return an error. Add Your Own Service Runner To add your own service runner, with its own service type, implement the org.moqui.impl.service.ServiceRunner interface and add a service-facade.service-type element in the Moqui Conf XML file. The ServiceRunner interface has 3 methods to implement: ServiceRunner init(ServiceFacadeImpl sfi); Map<String, Object> runService(ServiceDefinition sd, Map<String, Object> parameters) throws ServiceException; void destroy(); Here is an example of a service-facade.service-type element from the MoquiDefaultConf.xml file: <service-type name="script" runner-class="org.moqui.impl.service.runner.ScriptServiceRunner"/> The service-type.name attribute matches against the service.type attribute, and the runner-class attribute is simply the class that implements the ServiceRunner interface.

```
<service verb="send" noun="Email" type="script"
             location="classpath://org/moqui/impl/sendEmailTemplate.groovy" allow-remote="false">
        <implements service="org.moqui.EmailServices.send#EmailTemplate"/>
</service>
```

**Pattern 3:** Ecosystem Framework Business Artifacts Applications Add ons Forum Service Providers Issues & Tasks My Account My Requests (Issues) HiveMind PM Documentation Moqui Ecosystem Moqui Framework Mantle Business Artifacts Applications API JavaDoc Search Try the applications demo! Try POP Shop eCommerce! Comments? Questions? Get Involved? Join the Forum Wiki Spaces Mantle Business Artifacts Moqui Applications Moqui Community Moqui Framework Page Tree Moqui Framework All Pages Entity Data Import and Export Loading Entity XML and CSV Writing Entity XML Views and Forms for Easy View and Export Loading Entity XML and CSV Entity records can be imported from XML and CSV files using the EntityDataLoader. This can be done through the Entity Facade API using the* ec.entity*.makeDataLoader() method to get an object that implements the interface and using its methods to specify which data to load and then load it (using the load() method), get an EntityList of the records (using the list() method), or validate the data against the database (using the check() method). There are a few options for specifying which data to load. You can specify one or more locations using the location(String location) and locationList(List<String> locationList) methods. You can use text directly with the xmlText(String xmlText) and csvText(String csvText) methods. You can also load from component data directories and the entity-facade.load-data elements in the Moqui Conf XML file by specifying the types of data to load (only the files with a matching type will be loaded) using the dataTypes(Set<String> dataTypes) method. To set the transaction timeout to something different from the default, usually larger to handle processing large files, use the transactionTimeout(int tt) method. If you expect mostly inserts you can use pass true to the useTryInsert(boolean useTryInsert) method to improve performance by doing an insert without a query to see if the record exists and then if the insert fails with an error try an update. To help with foreign keys when records are out of order, but you know all will eventually be loaded, pass true to the dummyFks(boolean dummyFks) method and it will create empty records for foreign keys with no existing record. When the real record for the FK is loaded it will simply update the empty dummy record. To disable Entity ECA rules as the data is loaded pass true to the disableEntityEca(boolean disableEeca) method. For CSV files you can specify which characters to use when parsing the file(s) with csvDelimiter(char delimiter) (defaults to ‘,’), csvCommentStart(char commentStart) (defaults to ‘#’), and csvQuoteChar(char quoteChar) (defaults to ‘"’). Note that all of these methods on the EntityDataLoader return a self reference so you can chain calls, i.e. it is a DSL style API. For example: ec.entity.makeDataLoader().dataTypes([‘seed’, ‘demo’]).load() In addition to directly using the API you can load data using the* Tool* => Entity => Import screen in the tools component that comes in the default Moqui runtime. You can also load data using the command line with the executable WAR file using the *-load *argument. Here are the command line arguments available for the data loader: load -------- Run data loader types=<type>[,<type>] -- Data types to load (can be anything, common are: seed, seed-initial, demo, ...) location=<location> ---- Location of data file to load timeout=<seconds> ------ Transaction timeout for each file, defaults to 600 seconds (10 minutes) dummy-fks -------------- Use dummy foreign-keys to avoid referential integrity errors use-try-insert --------- Try insert and update on error instead of checking for record first tenantId=<tenantId> ---- ID for the Tenant to load the data into For example $ java -jar moqui.war load types=seed,demo The entity data XML file must have the entity-facade-xml root element which has a type attribute to specify the type of data in the file, which is compared with the specified types (if loading by specifying types) and only loaded if the type is in the set or if all types are loaded. Under that root element each element name is an entity or service name. For entities each attribute is a field name and for services each attribute is a input parameter. Here is an example of a entity data XML file: <moqui.basic.LocalizedMessage original="Example" locale="es" localized="Ejemplo"/> <moqui.basic.LocalizedMessage original="Example" locale="zh" localized="样例"/> Here is an example CSV file that calls a service (the same pattern applies for loading entity data): # first line is ${entityName or serviceName},${dataType} org.moqui.example.ExampleServices.create#Example, demo # second line is list of field names exampleTypeEnumId, statusId, exampleName, exampleSize, exampleDate # each additional line has values for those fields EXT_MADE_UP, EXST_IN_DESIGN, Test Example Name 3, 13, 2014-03-03 15:00:00 Writing Entity XML The easiest way export entity data to an XML file is to use the EntityDataWriter, which you can get with ec.entity.makeDataWriter(). Through this interface you can specify the names of entities to export from and various other options, then it does the query and exports to a file (with the int file(String filename) method), a directory with one file per entity (with the int directory(String path) method), or to a Writer object (with the int writer(Writer writer) method). All of these methods return an int with the number of records that were written. The methods for specifying options return a self reference to enable chaining calls. These are the methods for the query and export options: entityName(String entityName): Specify the name of an entity to query and export. Data is queried and exporting from entities in the order they are added by calling this or entityNames() multiple times. entityNames(List<String> entityNames): A List of entity names to query and export. Data is queried and exporting from entities in the order they are specified in this list and other calls to this or entityName(). dependentRecords(boolean dependents): If true export dependent records of each record. This dramatically slows down the export so only use it on smaller data sets. See the Dependent Entities section for details about what would be included. filterMap(Map<String, Object> filterMap): A Map of field name, value pairs to filter the results by. Each name/value is only used on entities that have a field matching the name. orderBy(List<String> orderByList): Field names to order (sort) the results by. Each name only used on entities with a field matching the name. May be called multiple times. Each entry may be a comma-separated list of field names. fromDate(Timestamp fromDate), thruDate(Timestamp thruDate): The from and thru dates to filter the records by, compared with the lastUpdatedStamp field which the Entity Facade automatically adds to each entity (unless turned off in the entity definition). Here is an example of an export of all OrderHeader records within a time range plus their dependents: ec.entity.makeDataWriter().entityName("mantle.order.OrderHeader").dependentRecords(true).orderBy(["orderId"]).fromDate(lastExportDate).thruDate(ec.user.nowTimestamp).file("/tmp/TestOrderExport.xml") Another way to export entity records is to do a query and get an EntityList or EntityListIterator object and call the int writeXmlText(Writer writer, String prefix, boolean dependents) method on it. This methods writes XML to the writer, optionally adding the prefix to the beginning of each element and including dependents. Similar to the entity data import UI you can export data using the Tool => Entity => Export screen in the tools component that comes in the default Moqui runtime. Views and Forms for Easy View and Export A number of tools come together to make it very easy to view and export database data that comes from a number of different tables. We have explored the options for static (XML), dynamic, and database defined entities. In the User Interface chapter there is detail about XML Forms, and in particular list forms. When a form-list has dynamic=true and a ${} string expansion in the auto-fields-entity.entity-name attribute then it will be expanded on the fly as the screen is rendered, meaning a single form can be used to generate tabular HTML or CSV output for any entity given an entity name as a screen parameter. To make things more interesting results viewed can be filtered generically using a dynamic form-single with an auto-fields-entity element to generate a search form based on the entity, and an entity-find with search-form-inputs to do the query based on the entity name parameter and the search parameters from the search form. Below is an example of these features along with a transition (DbView.csv) to export a CSV file. Don’t worry too much about all the details for screens, transitions, forms, and rendering options, they are covered in detail in the User Interface section. This screen definition is an excerpt from the ViewDbView.xml screen in the tools component that comes by default with Moqui Framework: <screen> <parameter name="dbViewEntityName" required="true"/> <transition name="filter"> <default-response url="."/> </transition> <transition name="DbView.csv"> <default-response url="."><parameter name="renderMode" value="csv"/> <parameter name="pageNoLimit" value="true"/><parameter name="lastStandalone" value="true"/></default-response> </transition> <actions> <entity-find entity-name="${dbViewEntityName}" list="dbViewList"> <search-form-inputs/> </entity-find> </actions> <widgets> <container> <link url="edit" text="Edit ${dbViewEntityName}"/> <link url="DbView.csv" text="Get as CSV"/> </container> <label text="Data View for: ${dbViewEntityName}" type="h2"/> <container-dialog id="FilterViewDialog" button-text="Filter ${ec.entity.getEntityDefinition(dbViewEntityName).getPrettyName(null, null)}"> <form-single name="FilterDbView" transition="filter" dynamic="true"> <auto-fields-entity entity-name="${dbViewEntityName}" field-type="find"/> <field name="dbViewEntityName"><default-field><hidden/></default-field></field> <field name="submitButton"><default-field title="Find"><submit/></default-field></field> </form-single> </container-dialog> <form-list name="ViewList" list="dbViewList" dynamic="true"> <auto-fields-entity entity-name="${dbViewEntityName}" field-type="display"/> </form-list> </widgets> </screen> While this screen is designed to be used by a user it can also be rendered outside a web or other UI context to generate CSV output to send to a file or other location. If you were to just write a screen for that it would be far simpler, basically just the parameter element, the single entity-find action, and the simple form-list definition. The transitions and the search form would not be needed. The code to do this through the screen renderer would look something like: ec.context.putAll([pageNoLimit:"true", lastStandalone:"true", dbViewEntityName: "moqui.example.ExampleStatusDetail"]) String csvOutput = ec.screen.makeRender().rootScreen("component://tools/screen/Tools/DataView/ViewDbView.xml").renderMode("csv").render()

```
ec.entity.makeDataLoader().dataTypes([‘seed’, ‘demo’]).load()
```

**Pattern 4:** Ecosystem Framework Business Artifacts Applications Add ons Forum Service Providers Issues & Tasks My Account My Requests (Issues) HiveMind PM Documentation Moqui Ecosystem Moqui Framework Mantle Business Artifacts Applications API JavaDoc Search Try the applications demo! Try POP Shop eCommerce! Comments? Questions? Get Involved? Join the Forum Wiki Spaces Mantle Business Artifacts Moqui Applications Moqui Community Moqui Framework Page Tree Moqui Framework All Pages Calling Services There are DSL-style interfaces available through the ServiceFacade (ec.getService(), or in Groovy ec.service) that have options applicable to the various ways of calling a service. All of these service call interfaces have name() methods to specify the service name, and parameter() and parameters() methods to specify the input parameters for the service. These and other methods on the various interfaces return an instance of themselves so that calls can be chained. Most have some variation of a call() method to actually call the service. For example: Map ahp = [visitId:ec.user.visitId, artifactType:artifactType, ...] ec.service.async().name("create", "moqui.server.ArtifactHit").parameters(ahp).call() Map result = ec.service.sync().name("org.moqui.impl.UserServices.create#UserAccount").parameters(params).call() The first service call is to an implicitly defined entity CrUD service to create a ArtifactHit record asynchronously. Note that for async() the call() method returns nothing and in this case the service call results are ignored. The second is a synchronous call to a defined service with a params input parameter Map, and because it is a sync() call the call() method returns a Map with the results of the service call. Beyond these basic methods each interface for different ways of calling a service has methods for applicable options, including: sync(): Call the service synchronously and return the results. requireNewTransaction(boolean requireNewTransaction): If true suspend/resume the current transaction (if a transaction is active) and begin a new transaction for the scope of this service call. multi(boolean mlt): If true expect multiple sets of parameters passed in a single map, each set with a suffix of an underscore and the row of the number, i.e. something like "userId_8" for the userId parameter in the 8th row. disableAuthz(): Disable authorization for the current thread during this service call. async(): Call the service asynchronously and ignore the results, get back a ServiceResultWaiter object to wait for the results, or pass in an implementation of the ServiceResultReceiver interface to receive the results when the service is complete. callFuture(): Calls the service (like call()) and returns a java.util.concurrent.Future instance used to wait for and receive the service results. distribute(boolean dist): If true the service call will be run distributed and may run on a different member of the cluster. Parameter entries MUST be java.io.Serializable (or java.io.Externalizable). If false it will be run local only (default). special(): Register the current service to be called when the current transaction is either committed (use registerOnCommit()) or rolled back (use registerOnRollback()). This interface does not have a call() method. Service Jobs Configure ad-hoc (explicitly executed) or schedule jobs using moqui.service.job.ServiceJob and moqui.service.job.ServiceJobParameter entities. Here is an example of a schedule job from MoquiInstallData.xml file, which is in place by default in Moqui <moqui.service.job.ServiceJob jobName="clean_ArtifactData_daily" description="Clean Artifact Data: ArtifactHit, ArtifactHitBin" serviceName="org.moqui.impl.ServerServices.clean#ArtifactData" cronExpression="0 0 2 * * ?" paused="N"> <parameters parameterName="daysToKeep" parameterValue="90"/> </moqui.service.job.ServiceJob> Tracks execution of Jobs using moqui.service.job.ServiceJobRun records Run service job through ServiceCallJob interface, ec.service.job() run(): Run a service job ec.service.job("ImportEntityDataSnapshot").parameters(context).run()

```
Map ahp = [visitId:ec.user.visitId, artifactType:artifactType, ...]
ec.service.async().name("create", "moqui.server.ArtifactHit").parameters(ahp).call()
Map result = ec.service.sync().name("org.moqui.impl.UserServices.create#UserAccount").parameters(params).call()
```

**Pattern 5:** Ecosystem Framework Business Artifacts Applications Add ons Forum Service Providers Issues & Tasks My Account My Requests (Issues) HiveMind PM Documentation Moqui Ecosystem Moqui Framework Mantle Business Artifacts Applications API JavaDoc Search Try the applications demo! Try POP Shop eCommerce! Comments? Questions? Get Involved? Join the Forum Wiki Spaces Mantle Business Artifacts Moqui Applications Moqui Community Moqui Framework Page Tree Moqui Framework All Pages The Entity Facade Basic CrUD Operations Finding Entity Records Flexible Finding with View Entities Basic CrUD Operations The basic CrUD operations for an entity record are available through the EntityValue interface. There are two main ways to get an EntityValue object: Make a Value (use ec.entity.makeValue(entityName)) Find a Value (more details on this below) Once you have an EntityValue object you can call the create(), update(), or delete() methods to perform the desired operation. There is also a createOrUpdate() method that will create a record if it doesn’t exist, or update it if it does. Note that all of these methods, like many methods on the EntityValue interface, return a self-reference for convenience so that you can chain operations. For example: ec.entity.makeValue("Example").setAll(fields).setSequencedIdPrimary().create() While this example is interesting, only in rare cases should you create a record directly using the Entity Facade API (accessed as ec.entity). You should generally do CrUD operations through services, and there are automatic CrUD services for all entities available through the Service Facade. These services have no definition, they exist implicitly and are driven only the entity definition. We’ll discuss the Service Facade more below in the context of the logic layer, but here is an example of what that operation would look like using an implicit automatic entity service: ec.service.sync().name("create#Example").parameters(fields).call() Most of the Moqui Framework API methods return a self-reference for convenient chaining of method calls like this. The main difference between the two is that one goes through the Service Facade and the other doesn’t. There are some advantages of going through the Service Facade (such as transaction management, flow control, security options, and so much more), but many things are the same between the two calls including automatic cleanup and type conversion of the fields passed in before performing the underlying operation. With the implicit automatic entity service you don’t have to explicitly set the sequenced primary ID as it automatically determines that there is a single primary and if it is not present in the parameters passed into the service then it will generate one. However you do the operation, only the entity fields that are modified or passed in are updated. The EntityValue object will keep track of which fields have been modified and only create or update those when the operation is done in the database. You can ask an EntityValue object if it is modified using the isModified() method, and you can restore it to its state in the database (populating all fields, not just the modified ones) using the refresh() method. If you want to find all the differences between the field values currently in the EntityValue and the corresponding column values in the database, use the checkAgainstDatabase(List messages) method. This method is used when asserting (as opposed to loading) an entity-facade-xml file and can also be used manually if you want to write Java or Groovy code check the state of data. Finding Entity Records Finding entity records is done using the EntityFind interface. Rather than using a number of different methods with different optional parameters through the EntityFind interface you can call methods for the aspects of the find that you care about, and ignore the rest. You can get a find object from the EntityFacade with something like: ec.getEntity().find("moqui.example.Example") Most of the methods on the EntityFind interface return a reference to the object so that you can chain method calls instead of putting them in separate statements. For example a find by the primary on the Example entity would look like this: EntityValue example = ec.entity.find("moqui.example.Example").condition("exampleId", exampleId).useCache(true).one() The EntityFind interface has methods on it for: conditions (both where and having) condition(String fieldName, Object value): Simple condition, named field equals value. condition(String fieldName, EntityCondition.ComparisonOperator operator, Object value): Compare the named field to the value using the operator which can be EQUALS, NOT_EQUAL, LESS_THAN, GREATER_THAN, LESS_THAN_EQUAL_TO, GREATER_THAN_EQUAL_TO, IN, NOT_IN, BETWEEN, LIKE, or NOT_LIKE. conditionToField(String fieldName, EntityCondition.ComparisonOperator operator, String toFieldName): Compare a field to another field using the operator. condition(Map<String, ?> fields): Constrain by each entry in the Map whose key matches a field name on the entity. If a field has been set with the same name and any of the Map keys, this will replace that field's value. Fields set in this way will be combined with other conditions (if applicable) just before doing the query. This will do conversions if needed from Strings to field types as needed, and will only get keys that match entity fields. In other words, it does the same thing as: EntityValue.setFields(fields, true, null, null). condition(EntityCondition condition): Add a condition created through the EntityConditionFactory. conditionDate(String fromFieldName, String thruFieldName, Timestamp compareStamp): Add conditions for the standard effective date query pattern including from field is null or earlier than or equal to compareStamp and thru field is null or later than or equal to compareStamp. havingCondition(EntityCondition condition): Add a condition created through the EntityConditionFactory to the having conditions. Having is the standard SQL concept and used for conditions applied after the grouping and functions. searchFormInputs(String inputFieldsMapName, String defaultOrderBy, boolean alwaysPaginate): Adds conditions for the fields found in the inputFieldsMapName Map. The fields and special fields with suffixes supported are the same as the *-find fields in the XML Forms. This means that you can use this to process the data from the various inputs generated by XML Forms. The suffixes include things like *_op for operators and *_ic for ignore case. If inputFieldsMapName is empty will look at the ec.web.parameters map if the web facade is available, otherwise the current context (ec.context). If there is not an orderByField parameter (one of the standard parameters for search XML Forms) defaultOrderBy is used instead. If alwaysPaginate is true pagination offset/limit will be set even if there is no pageIndex parameter. fields to select with selectField(String fieldToSelect) and/or selectFields(Collection<String> fieldsToSelect) fields to order the results by orderBy(String orderByFieldName): A field of the find entity to order the query by. Optionally add a " ASC" to the end or "+" to the beginning for ascending, or " DESC" to the end of "-" to the beginning for descending. If any other order by fields have already been specified this will be added to the end of the list. The String may be a comma-separated list of field names. Only fields that actually exist on the entity will be added to the order by list. orderBy(List<String> orderByFieldNames): Each List entry is passed to the orderBy(String orderByFieldName) method. whether or not to cache the results with useCache(Boolean useCache), defaults to the value on the entity definition the offset and limit to pass to the datasource to limit results offset(Integer offset): The offset, i.e. the starting row to return. Default (null) means start from the first actual row. Only applicable for list() and iterator() finds. offset(int pageIndex, int pageSize): Specify the offset in terms of page index and size. Actual offset is pageIndex * pageSize. limit(Integer limit): The limit, i.e. max number of rows to return. Default (null) means all rows. Only applicable for list() and iterator() finds. database options including distinct with the distinct(boolean distinct) method and for update with the forUpdate(boolean forUpdate) method JDBC options resultSetType(int resultSetType): Specifies how the ResultSet will be traversed. Available values are ResultSet.TYPE_FORWARD_ONLY, ResultSet.TYPE_SCROLL_INSENSITIVE (default) or ResultSet.TYPE_SCROLL_SENSITIVE. See the java.sql.ResultSet JavaDoc for more information. If you want it to be fast, use the common option ResultSet.TYPE_FORWARD_ONLY. For partial results where you want to jump to an index make sure to use ResultSet.TYPE_SCROLL_INSENSITIVE, which is the default. resultSetConcurrency(int resultSetConcurrency): Specifies whether or not the ResultSet can be updated. Available values are ResultSet.CONCUR_READ_ONLY (default) or ResultSet.CONCUR_UPDATABLE. Should pretty much always be ResultSet.CONCUR_READ_ONLY with the Entity Facade since updates are generally done as separate operations. fetchSize(Integer fetchSize): The JDBC fetch size for this query. Default (null) will fall back to datasource settings. This is not the fetch as in the OFFSET/FETCH SQL clause (use the offset/limit methods for that), and is rather the JDBC fetch to determine how many rows to get back on each round-trip to the database. Only applicable for list() and iterator() finds. maxRows(Integer maxRows): The JDBC max rows for this query. Default (null) will fall back to datasource settings. This is the maximum number of rows the ResultSet will keep in memory at any given time before releasing them and if requested they are retrieved from the database again. Only applicable for list() and iterator() finds. There are various options for conditions, some on the EntityFind interface itself and a more extensive set available through the EntityConditionFactory interface. To get an instance of this interface use the ec.entity.getConditionFactory() method, something like: EntityConditionFactory ecf = ec.entity.getConditionFactory(); ef.condition(ecf.makeCondition(...)); For find forms that follow the standard Moqui pattern (used in XML Form find fields and can be used in templates or JSON or XML parameter bodies too), just use the EntityFind.searchFormInputs() method. Once all of these options have been specified you can do any of these actual operations to get results or make changes: get a single EntityValue (one() method) get an EntityValueList with multiple value objects (list() method) get an* EntityListIterator* to handle a larger set of results in smaller batches (with the iterator() method) get a count of matching results (count() method) update all matching records with specified fields (updateAll() method) delete all matching records (delete() method) Flexible Finding with View Entities You probably noticed that the EntityFind interface operates on a single entity. To do a query across multiple entities joined together and represented by a single entity name you can create a static view entity using a XML definition that lives along side normal entity definitions. A view entity can also be defined in database records (in the DbViewEntity and related entities) or with dynamic view entities built with code using the EntityDynamicView interface (get an instance using the EntityFind.makeEntityDynamicView() method). Static View Entity A view entity consists of one or more member entities joined together with key mappings and a set of fields aliased from the member entities with optional functions associated with them. The view entity can also have conditions associated with it to encapsulate some sort of constraint on the data to be included in the view. Here is an example of a view-entity XML snippet from the ExampleViewEntities.xml file in the example component: <view-entity entity-name="ExampleFeatureApplAndEnum" package="moqui.example"> <member-entity entity-alias="EXFTAP" entity-name="ExampleFeatureAppl"/> <member-entity entity-alias="ENUM" entity-name="moqui.basic.Enumeration" join-from-alias="EXFTAP"> <key-map field-name="exampleFeatureApplEnumId"/> </member-entity> <alias-all entity-alias="EXFTAP"/> <alias-all entity-alias="ENUM"> <exclude field="sequenceNum"/> </alias-all> </view-entity> Just like an entity a view entity has a name and exists in a package using the entity-name and package-name attributes on the view-entity element. Each member entity is represented by a member-entity element and is uniquely identified by an alias in the entity-alias attribute. Part of the reason for this is that the same entity can be a member in a view entity multiple times with a different alias for each one. Note that the second member-entity element also has a join-from-alias attribute to specify that it is joined to the first member entity. Only the first member entity does not have a join-from-alias attribute. If you want the current member entity to be optional in the join (a left outer join in SQL) then just set the join-optional attribute to true. To describe how the two entities relate to each other use one or more key-map elements under the member-entity element. The key-map element has two attributes: field-name and related. Note that the related attribute is optional when matching the primary key field on the current member entity. Fields can be aliased in sets using the alias-all element, as in the example above, or individually using the alias element. If you want to have a function on the field then alias them individually with the alias element. Note for SQL databases that if any aliased field has a function then all other fields that don’t have a function but that are selected in the query will be added to the group by clause to avoid invalid SQL. View Entity Auto Minimize on Find When doing a query with the Entity Facade EntityFind you can specify fields to select and only those fields will be selected. For view entities this does a little more to give you a big boost in performance without much work. A common problem with static view entities is that you want to join in a bunch of member entities to provide a lot of options for search screens and similar flexible queries and when you do this the temporary table for the query in the database can get HUGE. When the common use is to only select certain fields and only have conditions and sorting on a limited set of fields you may end up joining in a number of tables that are not actually used. In effect you are asking the database to do a LOT more work that it really needs to for the data you need. One approach to solving this is to build a EntityDynamicView on the fly and only join in the entities you need for the specific query options used. This works, but is cumbersome. The easy approach is to just take advantage of the feature in EntityFind that automatically minimizes the fields and entities joined in for each particular query. On a view entity just specify the fields to select, the conditions, and the order by fields. The Entity Facade will automatically go through the view entity definition and only alias the fields that are used for one of these (select, conditions, order by), and only join in the entities with fields that are actually used (or that are need to connect a member entity with other member entities to complete the join). A good example of this is the FindPartyView view entity defined in the PartyViewEntities.xml file in Mantle Business Artifacts. This view entity has a respectable 13 member entities. Without the automatic minimize that would be 13 tables joined in to every query on it. With millions of customer records or other similarly large party data each query could take a few minutes. When only querying on a few fields and only joining in a small number of member entities and a minimal number of fields, the query gets down to sub-second times. The actual find is done by the mantle.party.PartyServices.find#Party service. The implementation of this service is a simple 45 line Groovy script (findParty.groovy), and most of that script is just adding conditions to the find based on parameter being specified or not. Doing the same thing with the EntityDynamicView approach requires hundreds of lines of much more complex scripting, more complex to both write and maintain. Database Defined View Entity In addition to defining view entities in XML you can also define them in database records using DbViewEntity and related entities. This is especially useful for building screens where the user defines a view on the fly (like the EditDbView.xml screen in the tools component, get to it in the menu with Tool => Data View), and then searches, views, and exports the data using a screen based on the user-defined view (like the ViewDbView.xml screen). There aren’t quite as many options when defining a DB view entity, but the main features are there and the same patterns apply. There is a view entity with a name (dbViewEntityName), package (packageName), and whether to cache results. It also has member entities (DbViewEntityMember), key maps to specify how the members join together (DbViewEntityKeyMap), and field aliases (DbViewEntityAlias). Here is an example, from the example component: <moqui.entity.view.DbViewEntity dbViewEntityName="StatusItemAndTypeDb" packageName="moqui.basic" cache="Y"> <moqui.entity.view.DbViewEntityMember entityAlias="SI" entityName="moqui.basic.StatusItem"/> <moqui.entity.view.DbViewEntityMember entityAlias="ST" entityName="moqui.basic.StatusType" joinFromAlias="SI"/> <moqui.entity.view.DbViewEntityKeyMap joinFromAlias="SI" entityAlias="ST" fieldName="statusTypeId"/> <moqui.entity.view.DbViewEntityAlias entityAlias="SI" fieldAlias="statusId"/> <moqui.entity.view.DbViewEntityAlias entityAlias="SI" fieldAlias="description"/> <moqui.entity.view.DbViewEntityAlias entityAlias="SI" fieldAlias="sequenceNum"/> <moqui.entity.view.DbViewEntityAlias entityAlias="ST" fieldAlias="typeDescription" fieldName="description"/> </moqui.entity.view.DbViewEntity> As you can see the entity and field names correlate with the XML element and attribute names. To use these entities just refer to them by name just like any other entity. Dynamic View Entity Even with the automatic view entity minimize that the Entity Facade does during a find there are still cases where you’ll need or want to build a view programmatically on the fly instead of having a statically defined view entity. To do this get an instance of the EntityDynamicView interface using the EntityFind.makeEntityDynamicView() method. This interface has methods on it that do the same things as the XML elements in a static view entity. Add member entities using the addMemberEntity(String entityAlias, String entityName, String joinFromAlias, Boolean joinOptional, Map<String, String> entityKeyMaps) method. One convenient option that doesn’t exist for static (XML defined) view entities is to join in a member entity based on a relationship definition. To do this use the addRelationshipMember(String entityAlias, String joinFromAlias, String relationshipName, Boolean joinOptional) method. To alias fields use the addAlias(String entityAlias, String name, String field, String function) method, the shortcut variation of it addAlias(String entityAlias, String name), or the addAliasAll(String entityAlias, String prefix) method. You can optionally specify a name for the dynamic view with the setEntityName() method, but usually this mostly useful for debugging and the default name (DynamicView) is usually just fine. Once this is done just specify conditions and doing the find operation as normal on the EntityFind object that you used to create the* EntityDynamicView* object.

```
ec.entity.makeValue("Example").setAll(fields).setSequencedIdPrimary().create()
```

## Reference Files

This skill includes comprehensive documentation in `references/`:

- **applications.md** - Applications documentation
- **framework.md** - Framework documentation
- **getting_started.md** - Getting Started documentation

Use `view` to read specific reference files when detailed information is needed.

## Working with This Skill

### For Beginners
Start with the getting_started or tutorials reference files for foundational concepts.

### For Specific Features
Use the appropriate category reference file (api, guides, etc.) for detailed information.

### For Code Examples
The quick reference section above contains common patterns extracted from the official docs.

## Resources

### references/
Organized documentation extracted from official sources. These files contain:
- Detailed explanations
- Code examples with language annotations
- Links to original documentation
- Table of contents for quick navigation

### scripts/
Add helper scripts here for common automation tasks.

### assets/
Add templates, boilerplate, or example projects here.

## Notes

- This skill was automatically generated from official documentation
- Reference files preserve the structure and examples from source docs
- Code examples include language detection for better syntax highlighting
- Quick reference patterns are extracted from common usage examples in the docs

## Updating

To refresh this skill with updated documentation:
1. Re-run the scraper with the same configuration
2. The skill will be rebuilt with the latest information
