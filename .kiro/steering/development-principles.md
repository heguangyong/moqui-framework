# 开发实施原则

本文档定义了Moqui AI平台项目开发过程中必须遵循的核心开发原则。

## 核心开发原则

### 1. Moqui框架对齐原则（最高优先级）

**原则**: 在开始任何功能开发前，必须深入理解Moqui Framework的实现模式和最佳实践。

**适用范围**: 所有Moqui组件开发、服务定义、屏幕配置

**实施标准**:
- **必须阅读CLAUDE.md参考文档**：理解Moqui开发的关键模式和常见陷阱
- **遵循双重菜单架构**：apps.xml和qapps.xml的正确配置方式
- **正确使用认证属性**：Service使用`authenticate`，Screen使用`require-authentication`
- **强制Chrome MCP验证**：每次前端修改后必须执行验证协议

### 1.1 Moqui新应用开发标准流程

**原则**: 遵循标准化的应用开发流程，避免常见错误和架构问题。

**适用范围**: 所有新Moqui应用的创建和开发

**常见错误模式（必须避免）**:
- **菜单配置错位**: 仅在qapps.xml配置，忽略apps.xml导致应用卡片不显示
- **认证属性混淆**: Service使用`require-authentication`，Screen使用`authenticate`
- **样式不一致**: 各页面使用不同的标题级别(h1/h2/h4)和样式
- **前端验证缺失**: 仅依赖代码分析，未使用Chrome MCP验证实际效果
- **功能架构混乱**: 在一个应用中混合不相关的功能模块

**标准开发流程**:
1. **应用架构设计**: 确定功能边界、用户角色、数据模型、API接口
2. **核心文件创建**: component.xml、主屏幕配置、服务定义
3. **双重注册机制**: apps.xml和qapps.xml都必须正确配置
4. **页面开发标准**: 统一样式规范、数据展示最佳实践
5. **服务开发规范**: 标准化的服务定义和错误处理

### 2. 技术栈一致性原则

**原则**: 保持技术栈的统一性，最大化代码复用和开发效率。

**适用范围**: 前端开发、后端服务、AI集成

**实施标准**:
- **后端统一**: Moqui Framework 3.1.0 + Java 21 + Groovy
- **前端统一**: Vue 3.x + Quasar 2.x + TypeScript
- **AI集成统一**: 智谱AI GLM-4/GLM-4V作为主要提供商
- **认证统一**: 纯JWT认证模式，无状态架构

### 3. 渐进式开发原则

**原则**: 采用渐进式开发方式，确保每个阶段都有可验证的成果。

**适用范围**: 所有功能开发和系统集成

**实施标准**:
- **MVP优先**: 先实现核心功能，再扩展高级特性
- **增量交付**: 每个开发周期都有可演示的功能
- **持续验证**: 每个功能点完成后立即测试验证
- **风险控制**: 复杂功能先做技术验证，再全面实施

### 4. 多模态AI集成原则

**原则**: 充分利用AI能力，实现真正的智能化业务流程。

**适用范围**: 所有涉及AI功能的开发

**实施标准**:
- **真实API优先**: 优先使用真实AI API，演示模式仅作备选
- **多模态支持**: 语音、图像、文本处理能力全面集成
- **智能化业务**: AI不仅是工具，更要驱动业务流程优化
- **用户体验**: AI功能要提升而非复杂化用户体验

## 质量保证原则

### 5. 强制验证协议

**原则**: 建立强制的质量验证机制，确保交付质量。

**适用范围**: 所有前端修改、API开发、系统集成

**实施标准**:
- **Chrome MCP验证**: 前端修改后必须执行截图验证
- **API测试验证**: 所有REST API必须通过Swagger文档验证
- **集成测试**: 跨组件功能必须进行端到端测试
- **性能验证**: 关键功能必须满足响应时间要求

### 6. 错误处理和恢复原则

**原则**: 建立完善的错误处理和恢复机制。

**适用范围**: 所有服务开发、前端组件、AI集成

**实施标准**:
- **优雅降级**: AI服务失败时提供备选方案
- **错误边界**: 前端组件错误不影响整体应用
- **日志记录**: 关键操作和错误必须记录日志
- **用户友好**: 错误信息对用户友好且可操作

### 7. 代码质量原则

**原则**: 保持高质量的代码标准和架构设计。

**适用范围**: 所有代码开发活动

**实施标准**:
- **高内聚低耦合**: 模块设计遵循单一职责原则
- **代码复用**: 避免重复代码，提取公共组件和服务
- **命名规范**: 使用清晰、一致的命名约定
- **文档同步**: 代码变更时同步更新相关文档

### 8. 主动重构和技术债务管理原则

**原则**: 识别代码异味并主动进行重构，持续管理技术债务，保持代码库健康。

**适用范围**: 所有代码生成、代码修改、功能扩展活动

**实施标准**:

#### 代码异味识别
识别以下常见的代码异味信号：
- **重复代码**: 相同或相似的代码片段在多处出现
- **过长函数/方法**: 单个函数超过50行或承担多个职责
- **过大类/组件**: 单个类或组件代码超过500行
- **过多参数**: 函数参数超过5个
- **复杂条件**: 嵌套的if-else超过3层
- **神秘命名**: 变量或函数名称不能清晰表达意图
- **注释过多**: 需要大量注释才能理解的代码
- **紧耦合**: 组件间存在过多的直接依赖

#### 重构触发条件
在以下情况下必须考虑重构：
- **添加新功能前**: 如果现有代码结构不利于新功能添加
- **修复Bug时**: 如果代码结构导致Bug难以定位或修复
- **代码审查时**: 审查过程中发现代码异味
- **性能问题**: 代码结构导致性能瓶颈
- **三次法则**: 相同代码出现第三次时必须提取复用

#### 重构策略
- **小步重构**: 每次重构保持小范围，确保可控
- **测试保护**: 重构前确保有足够的测试覆盖
- **持续集成**: 重构后立即运行测试验证
- **文档更新**: 重构涉及接口变更时同步更新文档
- **渐进式改进**: 大规模重构分解为多个小步骤

#### 常见重构模式
1. **提取方法**: 将长函数拆分为多个小函数
2. **提取类/组件**: 将大类拆分为多个职责单一的类
3. **引入参数对象**: 将多个参数封装为对象
4. **替换条件为多态**: 用多态替代复杂的条件判断
5. **移除中间人**: 消除不必要的委托层
6. **合并重复代码**: 提取公共逻辑到共享函数或组件

#### 设计模式敏感性
在代码设计和重构时，应主动识别和应用GoF 23种经典设计模式，提升代码的可维护性和扩展性：

**创建型模式** (Creational Patterns):
- **单例模式 (Singleton)**: 确保类只有一个实例，如配置管理器、连接池
- **工厂方法 (Factory Method)**: 定义创建对象的接口，让子类决定实例化哪个类
- **抽象工厂 (Abstract Factory)**: 创建相关或依赖对象的家族，如UI组件工厂
- **建造者 (Builder)**: 分步骤构建复杂对象，如查询构建器、配置构建器
- **原型 (Prototype)**: 通过复制现有实例创建新对象

**结构型模式** (Structural Patterns):
- **适配器 (Adapter)**: 将一个接口转换为客户期望的另一个接口，如API适配器
- **桥接 (Bridge)**: 将抽象与实现分离，使它们可以独立变化
- **组合 (Composite)**: 将对象组合成树形结构，如菜单树、组织结构
- **装饰器 (Decorator)**: 动态地给对象添加职责，如日志装饰器、缓存装饰器
- **外观 (Facade)**: 为子系统提供统一的高层接口，如服务门面
- **享元 (Flyweight)**: 运用共享技术有效支持大量细粒度对象
- **代理 (Proxy)**: 为其他对象提供代理以控制对这个对象的访问，如懒加载代理

**行为型模式** (Behavioral Patterns):
- **责任链 (Chain of Responsibility)**: 将请求沿着处理者链传递，如中间件、过滤器链
- **命令 (Command)**: 将请求封装为对象，如操作历史、事务管理
- **解释器 (Interpreter)**: 定义语言的文法，并建立解释器来解释该语言中的句子
- **迭代器 (Iterator)**: 提供顺序访问聚合对象元素的方法
- **中介者 (Mediator)**: 用中介对象封装一系列对象交互，如事件总线
- **备忘录 (Memento)**: 在不破坏封装的前提下捕获对象内部状态，如撤销功能
- **观察者 (Observer)**: 定义对象间一对多依赖，如事件监听、响应式数据
- **状态 (State)**: 允许对象在内部状态改变时改变其行为，如工作流状态机
- **策略 (Strategy)**: 定义算法家族并使它们可互换，如排序策略、支付策略
- **模板方法 (Template Method)**: 定义算法骨架，将某些步骤延迟到子类
- **访问者 (Visitor)**: 表示作用于对象结构中元素的操作

**模式识别信号**:
- **重复的对象创建逻辑** → 考虑工厂模式或建造者模式
- **复杂的条件分支** → 考虑策略模式或状态模式
- **需要扩展功能但不修改原类** → 考虑装饰器模式
- **多个对象需要协调交互** → 考虑中介者模式或观察者模式
- **需要统一多个子系统的接口** → 考虑外观模式
- **需要控制对象访问** → 考虑代理模式
- **需要处理树形结构** → 考虑组合模式
- **需要顺序处理请求** → 考虑责任链模式

**模式应用原则**:
- **不要过度设计**: 只在真正需要时应用设计模式
- **优先简单**: 简单的解决方案优于复杂的模式
- **渐进式应用**: 先实现功能，再根据需要重构为模式
- **组合使用**: 多个模式可以组合使用解决复杂问题
- **文档说明**: 使用设计模式时在代码注释中说明模式名称和意图

#### 技术债务管理
- **债务记录**: 在代码中使用`// TODO: TECH_DEBT`标记技术债务
- **债务评估**: 定期评估技术债务的影响和优先级
- **债务偿还**: 在每个迭代中分配时间偿还技术债务
- **债务可视化**: 维护技术债务清单，跟踪偿还进度

#### 重构检查清单
在代码生成或修改时，主动检查：
- [ ] 是否存在重复代码可以提取？
- [ ] 函数/方法是否过长需要拆分？
- [ ] 类/组件是否职责单一？
- [ ] 命名是否清晰表达意图？
- [ ] 是否有过度复杂的条件判断？
- [ ] 是否有不必要的依赖可以解耦？
- [ ] 是否有遗留的技术债务需要处理？
- [ ] 是否可以应用合适的设计模式改善设计？
- [ ] 现有代码是否误用或过度使用了设计模式？

## 环境和部署原则

### 9. 多环境管理原则

**原则**: 明确不同环境的配置和操作要求。

**适用范围**: 开发、测试、生产环境的所有操作

**实施标准**:
- **环境隔离**: 开发、测试、生产环境完全隔离
- **配置管理**: 环境特定配置通过配置文件管理
- **权限控制**: 不同环境有不同的访问权限要求
- **操作记录**: 生产环境操作必须有审计记录

### 10. 容器化和自动化原则

**原则**: 利用容器化技术实现环境一致性和部署自动化。

**适用范围**: 应用部署、服务管理、环境配置

**实施标准**:
- **Docker容器**: 所有服务使用Docker容器部署
- **自动化部署**: 使用CI/CD流水线自动化部署
- **配置即代码**: 基础设施配置使用代码管理
- **监控告警**: 建立完善的监控和告警机制

## 协作和沟通原则

### 11. 文档驱动开发原则

**原则**: 以文档为驱动的开发模式，确保需求清晰和实施准确。

**适用范围**: 所有功能开发和系统设计

**实施标准**:
- **Specs先行**: 功能开发前必须完成specs文档
- **设计评审**: 重要功能必须进行设计评审
- **实施跟踪**: 通过tasks.md跟踪实施进度
- **变更管理**: 需求变更必须更新相关文档

### 12. 知识共享原则

**原则**: 建立有效的知识共享和传承机制。

**适用范围**: 技术决策、问题解决、最佳实践

**实施标准**:
- **技术分享**: 定期进行技术分享和讨论
- **问题记录**: 重要问题和解决方案必须记录
- **最佳实践**: 及时总结和分享最佳实践
- **代码评审**: 重要代码变更必须进行评审

## 安全和合规原则

### 13. 安全优先原则

**原则**: 在所有开发活动中优先考虑安全性。

**适用范围**: 认证授权、数据处理、API设计

**实施标准**:
- **JWT安全**: 正确实施JWT认证和授权机制
- **数据保护**: 敏感数据必须加密存储和传输
- **输入验证**: 所有用户输入必须进行验证和清理
- **权限控制**: 实施最小权限原则

### 14. 合规性原则

**原则**: 确保系统符合相关法规和标准要求。

**适用范围**: 数据处理、用户隐私、系统审计

**实施标准**:
- **数据合规**: 遵循数据保护相关法规
- **审计日志**: 关键操作必须有审计记录
- **用户权利**: 保护用户数据权利和隐私
- **定期评估**: 定期进行合规性评估和改进

## 执行检查清单

在完成每个开发任务时，确认以下事项：

**Moqui框架对齐检查（必须）：**
- [ ] 是否已阅读相关的CLAUDE.md指导？
- [ ] 菜单配置是否正确（apps.xml + qapps.xml）？
- [ ] 认证属性是否使用正确？
- [ ] 是否执行了Chrome MCP验证？

**技术质量检查：**
- [ ] 代码是否符合技术栈一致性要求？
- [ ] 是否有适当的错误处理机制？
- [ ] AI集成是否遵循真实API优先原则？
- [ ] 是否有必要的测试覆盖？
- [ ] 是否识别并处理了代码异味？
- [ ] 是否有重复代码需要提取？
- [ ] 是否记录了新增的技术债务？
- [ ] 是否考虑了合适的设计模式应用？

**文档和协作检查：**
- [ ] 相关文档是否已更新？
- [ ] 是否需要进行代码评审？
- [ ] 重要决策是否已记录？
- [ ] 是否需要知识分享？

**安全和合规检查：**
- [ ] 是否考虑了安全性要求？
- [ ] 敏感数据是否得到保护？
- [ ] 是否有必要的审计记录？
- [ ] 是否符合合规性要求？

---

**文档版本**: v1.1  
**最后更新**: 2025年1月14日  
**主要更新**: 新增"主动重构和技术债务管理原则"（原则8）  
**适用范围**: 整个Moqui AI平台项目  
**审批状态**: 待审批