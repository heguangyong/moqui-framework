class g{static{this.MIN_APPEARANCES_FOR_MAJOR=3}static{this.MIN_APPEARANCES_FOR_SUPPORTING=2}static{this.PROTAGONIST_INDICATORS=["主角","主人公","我","自己","protagonist","main character","hero","heroine"]}static{this.ANTAGONIST_INDICATORS=["反派","敌人","对手","坏人","antagonist","villain","enemy","rival"]}static identifyCharacters(t){const e=new Map,i=new Map,s=new Map;for(const n of t)for(const a of n.scenes){const o=this.extractCharacterMentions(a.content);for(const l of o){const c=this.normalizeCharacterName(l);s.set(c,(s.get(c)||0)+1);const p={id:`${a.id}_${c}_${Date.now()}`,characterId:c,sceneId:a.id,description:this.extractCharacterDescription(a.content,l),importance:this.determineAppearanceImportance(a.content,l)};i.has(c)||i.set(c,[]),i.get(c).push(p)}}for(const[n,a]of s.entries()){const o=i.get(n)||[],l=this.classifyCharacterRole(n,a,o,t);if(a>=1||l==="protagonist"||l==="antagonist"){const c={id:this.generateCharacterId(n),name:n,role:l,attributes:this.extractCharacterAttributes(n,o,t),relationships:[],appearances:o};e.set(n,c)}}const r=Array.from(e.values());return this.identifyRelationships(r,t),r}static extractCharacterMentions(t){const e=[],i=/[王李张刘陈杨黄赵吴周徐孙马朱胡郭何高林罗郑梁谢宋唐许韩冯邓曹彭曾萧田董袁潘于蒋蔡余杜叶程苏魏吕丁任沈姚卢姜崔钟谭陆汪范金石廖贾夏韦付方白邹孟熊秦邱江尹薛闫段雷侯龙史陶黎贺顾毛郝龚邵万钱严覃武戴莫孔向汤][\u4e00-\u9fa5]{1,2}/g,s=/\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\b/g,r=t.match(i);if(r){const a=r.filter(o=>this.isValidCharacterName(o));e.push(...a)}const n=t.match(s);if(n){const a=n.filter(o=>this.isValidCharacterName(o));e.push(...a)}return[...new Set(e)]}static isValidCharacterName(t){if(["The","This","That","Chapter","Scene","When","Where","What","How","Why","And","But","For","With","From","After","Before","During","While","第一","第二","第三","第四","第五","第六","第七","第八","第九","第十","今天","昨天","明天","现在","以前","以后","时候","地方","东西","事情","问题","方法","办法","结果","原因","情况","条件","机会","可能","应该"].includes(t)||t.length<2||t.length>4)return!1;if(/[\u4e00-\u9fa5]/.test(t)){const i=["是","在","有","和","与","或","但","而","就","都","也","还","又","才","只","不","没","很","太","最","更","比","像","如","若","要","会","能","可","应","该","将","把","被","让","使","给","为","向","从","到","于","对","关","按","根","据","由","经","通","过","来","去","上","下","进","出","回","起","开","关","看","听","说","做","走","跑","站","坐","躺","睡","吃","喝","笑","哭","想","知","道","等"];for(const s of i)if(t.includes(s))return!1;if(t.length===2||t.length===3)return!0}return!0}static normalizeCharacterName(t){let e=t.trim();return/^[A-Za-z\s]+$/.test(e)&&(e=e.toLowerCase().replace(/\b\w/g,i=>i.toUpperCase())),e}static classifyCharacterRole(t,e,i,s){const r=s.map(l=>l.content).join(" "),n=this.getCharacterContext(t,r);if(this.PROTAGONIST_INDICATORS.some(l=>n.includes(l)))return"protagonist";if(this.ANTAGONIST_INDICATORS.some(l=>n.includes(l)))return"antagonist";const a=i.filter(l=>l.importance==="major").length,o=i.length;return e>=10&&a>=this.MIN_APPEARANCES_FOR_MAJOR?"protagonist":e>=5&&o>=this.MIN_APPEARANCES_FOR_SUPPORTING?"supporting":"minor"}static getCharacterContext(t,e){const i=[],s=new RegExp(`(.{0,50})${t}(.{0,50})`,"gi");let r;for(;(r=s.exec(e))!==null;)i.push(r[0]);return i.join(" ")}static extractCharacterDescription(t,e){const i=new RegExp(`(.{0,100})${e}(.{0,100})`,"i"),s=t.match(i);if(s){const r=s[0];return this.extractDescriptiveWords(r).join(", ")}return""}static extractDescriptiveWords(t){const e=[],i=/[美丑高矮胖瘦年轻年老聪明愚蠢善良邪恶勇敢胆小温柔粗暴安静吵闹快乐悲伤愤怒平静紧张放松严肃幽默冷漠热情骄傲谦虚自信害羞外向内向活泼沉默机智迟钝细心粗心耐心急躁诚实虚伪友好敌对礼貌粗鲁优雅粗俗文雅野蛮]/g,s=/\b(beautiful|ugly|tall|short|fat|thin|young|old|smart|stupid|kind|evil|brave|coward|gentle|rough|quiet|loud|happy|sad|angry|calm|nervous|relaxed|serious|funny|cold|warm|proud|humble|confident|shy|outgoing|introverted|lively|silent|clever|slow|careful|careless|patient|impatient|honest|dishonest|friendly|hostile|polite|rude|elegant|vulgar|refined|wild)\b/gi,r=t.match(i);r&&e.push(...r);const n=t.match(s);return n&&e.push(...n.map(a=>a.toLowerCase())),[...new Set(e)]}static determineAppearanceImportance(t,e){const i=(t.match(new RegExp(e,"gi"))||[]).length,s=t.length,r=i/(s/100);return r>2||i>=5?"major":r>.5||i>=2?"minor":"background"}static extractCharacterAttributes(t,e,i){const s=e.map(a=>a.description).join(" "),r=i.map(a=>a.content).join(" "),n=this.getCharacterContext(t,r);return{appearance:this.extractAppearanceDescription(s+" "+n),personality:this.extractPersonalityTraits(n),age:this.extractAge(n),gender:this.extractGender(n,t),occupation:this.extractOccupation(n),background:this.extractBackground(n)}}static extractAppearanceDescription(t){return this.extractDescriptiveWords(t).filter(s=>/^(美|丑|高|矮|胖|瘦|年轻|年老|beautiful|ugly|tall|short|fat|thin|young|old)/.test(s)).join(", ")||"Unknown appearance"}static extractPersonalityTraits(t){return this.extractDescriptiveWords(t).filter(s=>!/^(美|丑|高|矮|胖|瘦|年轻|年老|beautiful|ugly|tall|short|fat|thin|young|old)/.test(s)).join(", ")||"Unknown personality"}static extractAge(t){const e=/(\d+)[岁年]|(\d+)\s*years?\s*old/i,i=t.match(e);if(i)return parseInt(i[1]||i[2])}static extractGender(t,e){if(/她|女|girl|woman|female|lady/i.test(t))return"female";if(/他|男|boy|man|male|gentleman/i.test(t))return"male";if(/[美丽花香雪月莲梅兰菊竹]/.test(e))return"female";if(/[强勇刚雄龙虎豹鹰]/.test(e))return"male"}static extractOccupation(t){const e=[/是(.{1,10}?)[师生员工人]/,/works?\s+as\s+a?\s*(.{1,20}?)[\s,.]/,/职业是(.{1,10}?)/,/从事(.{1,10}?)工作/];for(const i of e){const s=t.match(i);if(s)return s[1].trim()}}static extractBackground(t){const e=[/出生于(.{1,20}?)/,/来自(.{1,20}?)/,/born\s+in\s+(.{1,20}?)[\s,.]/,/from\s+(.{1,20}?)[\s,.]/];for(const i of e){const s=t.match(i);if(s)return s[1].trim()}}static identifyRelationships(t,e){const i=e.map(s=>s.content).join(" ");for(let s=0;s<t.length;s++)for(let r=s+1;r<t.length;r++){const n=t[s],a=t[r],o=this.analyzeRelationship(n.name,a.name,i);o&&(n.relationships.push({id:`rel_${n.id}_${a.id}`,fromCharacterId:n.id,toCharacterId:a.id,relationshipType:o.type,description:o.description,strength:o.strength}),a.relationships.push({id:`rel_${a.id}_${n.id}`,fromCharacterId:a.id,toCharacterId:n.id,relationshipType:o.reciprocal||o.type,description:o.description,strength:o.strength}))}}static analyzeRelationship(t,e,i){const s=new RegExp(`(.{0,100})(${t}.{0,50}${e}|${e}.{0,50}${t})(.{0,100})`,"gi"),r=i.match(s);if(!r||r.length===0)return null;const n=r.join(" "),a=Math.min(r.length,10),o=this.determineRelationshipType(n,t,e);return{type:o.type,reciprocal:o.reciprocal,description:`Relationship inferred from ${r.length} co-occurrences`,strength:a}}static determineRelationshipType(t,e,i){return/父亲|爸爸|father|dad/i.test(t)?{type:"father",reciprocal:"child"}:/母亲|妈妈|mother|mom/i.test(t)?{type:"mother",reciprocal:"child"}:/兄弟|brother/i.test(t)?{type:"brother"}:/姐妹|sister/i.test(t)?{type:"sister"}:/恋人|情人|男友|女友|boyfriend|girlfriend|lover/i.test(t)?{type:"romantic_partner"}:/丈夫|妻子|husband|wife/i.test(t)?{type:"spouse"}:/老板|上司|boss|supervisor/i.test(t)?{type:"boss",reciprocal:"subordinate"}:/同事|colleague/i.test(t)?{type:"colleague"}:/朋友|friend/i.test(t)?{type:"friend"}:/敌人|对手|enemy|rival/i.test(t)?{type:"enemy"}:{type:"acquaintance"}}static generateCharacterId(t){return`char_${t.toLowerCase().replace(/\s+/g,"_")}_${Date.now()}`}static trackRecurringCharacters(t,e){for(const i of t){const s=new Map;for(const o of i.appearances){const l=e.find(c=>c.scenes.some(p=>p.id===o.sceneId));l&&s.set(l.id,(s.get(l.id)||0)+1)}const r=s.size,n=e.length,a=r/n;a>=.7&&i.role==="supporting"?i.role="protagonist":a>=.4&&i.role==="minor"&&(i.role="supporting")}return t}static createLockedProfile(t,e){const i={characterId:t.id,lockedAttributes:{...t.attributes},visualReference:e,consistencyRules:this.generateConsistencyRules(t),isLocked:!0};return this.storeLockedProfile(i),i}static generateConsistencyRules(t){const e=[];return t.attributes.appearance&&e.push({id:`appearance_${t.id}`,name:"Appearance Consistency",description:"Character appearance must remain consistent across all scenes",validator:i=>this.validateAppearanceConsistency(i,t.attributes.appearance),isActive:!0}),t.attributes.personality&&e.push({id:`personality_${t.id}`,name:"Personality Consistency",description:"Character personality traits must remain consistent",validator:i=>this.validatePersonalityConsistency(i,t.attributes.personality),isActive:!0}),t.attributes.age&&e.push({id:`age_${t.id}`,name:"Age Consistency",description:"Character age must remain consistent unless story progression warrants change",validator:i=>this.validateAgeConsistency(i,t.attributes.age),isActive:!0}),t.attributes.gender&&e.push({id:`gender_${t.id}`,name:"Gender Consistency",description:"Character gender must remain consistent",validator:i=>this.validateGenderConsistency(i,t.attributes.gender),isActive:!0}),t.relationships.length>0&&e.push({id:`relationships_${t.id}`,name:"Relationship Consistency",description:"Character relationships must remain consistent with established dynamics",validator:i=>this.validateRelationshipConsistency(i,t.relationships),isActive:!0}),e}static validateAppearanceConsistency(t,e){const i=[],s=[],r=this.extractAppearanceDescription(t),n=e.split(",").map(l=>l.trim().toLowerCase()),a=r.split(",").map(l=>l.trim().toLowerCase()),o=this.findAppearanceConflicts(n,a);for(const l of o)i.push({code:"APPEARANCE_CONFLICT",message:`Character appearance conflict: expected "${l.expected}" but found "${l.actual}"`,field:"appearance",severity:"error"});return{isValid:i.length===0,errors:i,warnings:s}}static findAppearanceConflicts(t,e){const i=[],s=[["tall","short"],["高","矮"],["fat","thin"],["胖","瘦"],["young","old"],["年轻","年老"],["beautiful","ugly"],["美","丑"]];for(const r of t)for(const n of e)for(const[a,o]of s)(r.includes(a)&&n.includes(o)||r.includes(o)&&n.includes(a))&&i.push({expected:r,actual:n});return i}static validatePersonalityConsistency(t,e){const i=[],s=[],r=this.extractPersonalityTraits(t),n=e.split(",").map(l=>l.trim().toLowerCase()),a=r.split(",").map(l=>l.trim().toLowerCase()),o=this.findPersonalityConflicts(n,a);for(const l of o)i.push({code:"PERSONALITY_CONFLICT",message:`Character personality conflict: expected "${l.expected}" but found "${l.actual}"`,field:"personality",severity:"error"});return{isValid:i.length===0,errors:i,warnings:s}}static findPersonalityConflicts(t,e){const i=[],s=[["kind","evil"],["善良","邪恶"],["brave","coward"],["勇敢","胆小"],["gentle","rough"],["温柔","粗暴"],["quiet","loud"],["安静","吵闹"],["happy","sad"],["快乐","悲伤"],["calm","angry"],["平静","愤怒"],["confident","shy"],["自信","害羞"],["outgoing","introverted"],["外向","内向"],["patient","impatient"],["耐心","急躁"],["honest","dishonest"],["诚实","虚伪"]];for(const r of t)for(const n of e)for(const[a,o]of s)(r.includes(a)&&n.includes(o)||r.includes(o)&&n.includes(a))&&i.push({expected:r,actual:n});return i}static validateAgeConsistency(t,e){const i=[],s=[],r=this.extractAge(t);if(r!==void 0){const n=Math.abs(r-e);n>5?i.push({code:"AGE_CONFLICT",message:`Character age conflict: expected around ${e} but found ${r}`,field:"age",severity:"error"}):n>2&&s.push({code:"AGE_INCONSISTENCY",message:`Character age inconsistency: expected ${e} but found ${r}`,field:"age",severity:"warning"})}return{isValid:i.length===0,errors:i,warnings:s}}static validateGenderConsistency(t,e){const i=[],s=[],r=this.extractGender(t,"");return r&&r!==e&&i.push({code:"GENDER_CONFLICT",message:`Character gender conflict: expected "${e}" but found "${r}"`,field:"gender",severity:"error"}),{isValid:i.length===0,errors:i,warnings:s}}static validateRelationshipConsistency(t,e){return{isValid:!0,errors:[],warnings:[]}}static storeLockedProfile(t){const e=`locked_profile_${t.characterId}`;localStorage.setItem(e,JSON.stringify(t));const i=this.getStoredProfilesList(),s=i.findIndex(r=>r.characterId===t.characterId);s>=0?i[s]=t:i.push(t),localStorage.setItem("locked_profiles_list",JSON.stringify(i))}static getLockedProfile(t){const e=`locked_profile_${t}`,i=localStorage.getItem(e);if(!i)return null;try{return JSON.parse(i)}catch(s){return console.error("Failed to parse locked profile:",s),null}}static getStoredProfilesList(){const t=localStorage.getItem("locked_profiles_list");return t?JSON.parse(t):[]}static updateLockedProfile(t,e){const i=this.getLockedProfile(t);if(!i)return null;const s={...i,...e};return this.storeLockedProfile(s),s}static unlockProfile(t){const e=this.getLockedProfile(t);return e?(e.isLocked=!1,this.storeLockedProfile(e),!0):!1}static createRelationshipMapping(t){const e=new Map;for(const i of t)e.set(i.id,i.relationships);return e}static updateRelationshipMapping(t,e){const i=t.get(e.fromCharacterId)||[],s=i.find(r=>r.toCharacterId===e.toCharacterId);s?(s.relationshipType=e.relationshipType,s.description=e.description,s.strength=Math.max(s.strength||0,e.strength||0)):i.push(e),t.set(e.fromCharacterId,i)}static validateCharacterConsistency(t,e,i){const s=i.find(o=>o.characterId===e);if(!s||!s.isLocked)return{characterId:e,violations:[],score:100,recommendations:["Character profile is not locked - consider locking for consistency enforcement"]};const r=[],n=[];for(const o of s.consistencyRules)if(o.isActive){const l=o.validator(t);if(!l.isValid)for(const c of l.errors)r.push({type:this.mapErrorToViolationType(c.code),description:c.message,severity:c.severity==="error"?"high":"medium",affectedScenes:[t.substring(0,50)+"..."]});for(const c of l.warnings)n.push(c.message)}const a=this.calculateConsistencyScore(r);return{characterId:e,violations:r,score:a,recommendations:n}}static mapErrorToViolationType(t){return t.includes("APPEARANCE")||t.includes("AGE")||t.includes("GENDER")?"visual":t.includes("PERSONALITY")||t.includes("RELATIONSHIP")?"behavioral":"dialogue"}static calculateConsistencyScore(t){if(t.length===0)return 100;let e=0;for(const i of t)switch(i.severity){case"high":e+=20;break;case"medium":e+=10;break;case"low":e+=5;break}return Math.max(0,100-e)}static enforceConsistencyConstraints(t,e,i){const s=this.validateCharacterConsistency(t,e,i);if(s.violations.length===0)return{isValid:!0,violations:[]};let r=t;const n=[];for(const a of s.violations)if(a.severity==="high"){const o=this.attemptViolationCorrection(r,a,e,i);o.success?r=o.correctedContent:n.push(a)}else n.push(a);return{isValid:n.length===0,correctedContent:r!==t?r:void 0,violations:n}}static attemptViolationCorrection(t,e,i,s){const r=s.find(a=>a.characterId===i);if(!r)return{success:!1};let n=t;switch(e.type){case"visual":n=this.correctVisualViolation(t,e,r);break;case"behavioral":n=this.correctBehavioralViolation(t,e,r);break;case"dialogue":n=this.correctDialogueViolation(t,e,r);break}return{success:n!==t,correctedContent:n!==t?n:void 0}}static correctVisualViolation(t,e,i){let s=t;if(e.description.includes("appearance conflict")){const r=i.lockedAttributes.appearance;if(r){const n=r.split(",").map(a=>a.trim());for(const a of n)(a.includes("tall")||a.includes("高"))&&(s=s.replace(/short|矮/gi,a)),(a.includes("young")||a.includes("年轻"))&&(s=s.replace(/old|年老/gi,a))}}return s}static correctBehavioralViolation(t,e,i){let s=t;if(e.description.includes("personality conflict")){const r=i.lockedAttributes.personality;if(r){const n=r.split(",").map(a=>a.trim());for(const a of n)(a.includes("kind")||a.includes("善良"))&&(s=s.replace(/evil|邪恶/gi,a)),(a.includes("brave")||a.includes("勇敢"))&&(s=s.replace(/coward|胆小/gi,a))}}return s}static correctDialogueViolation(t,e,i){return t}static maintainRelationshipDynamics(t,e,i){const s=[],r=[];for(let n=0;n<e.length;n++)for(let a=n+1;a<e.length;a++){const o=e[n],l=e[a],p=(i.get(o)||[]).find(h=>h.toCharacterId===l);if(p){const h=this.validateCharacterInteraction(t,o,l,p);s.push(...h.errors),r.push(...h.warnings)}}return{isValid:s.length===0,errors:s,warnings:r}}static validateCharacterInteraction(t,e,i,s){const r=[],n=[],a=s.relationshipType.toLowerCase();return a==="enemy"||a==="rival"?/friend|friendly|kind|nice|love/i.test(t)&&n.push({code:"RELATIONSHIP_INCONSISTENCY",message:`Characters ${e} and ${i} are established as enemies but content shows friendly interaction`,field:"relationship",severity:"warning"}):(a==="friend"||a==="romantic_partner")&&/enemy|hate|hostile|fight|attack/i.test(t)&&n.push({code:"RELATIONSHIP_INCONSISTENCY",message:`Characters ${e} and ${i} are established as ${a} but content shows hostile interaction`,field:"relationship",severity:"warning"}),{isValid:r.length===0,errors:r,warnings:n}}static createAttributeValidationRules(t){return this.generateConsistencyRules(t)}static validateCharacterAttributes(t,e){const i=[],s=[];for(const r of e)if(r.isActive){const n=[t.attributes.appearance,t.attributes.personality,t.attributes.age?.toString(),t.attributes.gender,t.attributes.occupation,t.attributes.background].filter(Boolean).join(" "),a=r.validator(n);i.push(...a.errors),s.push(...a.warnings)}return{isValid:i.length===0,errors:i,warnings:s}}static integrateNewCharacter(t,e,i){const s=[],r=[],n=[...e],a=e.find(c=>this.normalizeCharacterName(c.name)===this.normalizeCharacterName(t.name));a&&(s.push(`Character name conflict: "${t.name}" already exists as "${a.name}"`),t.name=`${t.name}_${Date.now()}`,t.id=this.generateCharacterId(t.name));const o=i.map(c=>c.content).join(" ");for(const c of e){const p=this.analyzeRelationship(t.name,c.name,o);if(p){const h={id:`rel_${t.id}_${c.id}`,fromCharacterId:t.id,toCharacterId:c.id,relationshipType:p.type,description:p.description,strength:p.strength},d={id:`rel_${c.id}_${t.id}`,fromCharacterId:c.id,toCharacterId:t.id,relationshipType:p.reciprocal||p.type,description:p.description,strength:p.strength};t.relationships.push(h),c.relationships.push(d),r.push(h,d)}}const l=this.detectRelationshipConflicts(t,e);return s.push(...l),n.push(t),{updatedCharacters:n,newRelationships:r,conflicts:s}}static detectRelationshipConflicts(t,e){const i=[];for(const s of t.relationships){const r=e.find(n=>n.id===s.toCharacterId);if(r){const n=r.relationships.find(a=>a.toCharacterId===t.id);n&&this.areRelationshipsConflicting(s,n)&&i.push(`Relationship conflict between "${t.name}" and "${r.name}": new relationship "${s.relationshipType}" conflicts with existing "${n.relationshipType}"`)}}return i}static areRelationshipsConflicting(t,e){const i=[["friend","enemy"],["romantic_partner","enemy"],["family","enemy"],["boss","subordinate"],["parent","child"]],s=t.relationshipType.toLowerCase(),r=e.relationshipType.toLowerCase();return i.some(([n,a])=>s.includes(n)&&r.includes(a)||s.includes(a)&&r.includes(n))}static updateCharacterNetwork(t,e){const i=new Map(t.map(s=>[s.id,s]));for(const s of e){const r=i.get(s.fromCharacterId);if(r){const n=r.relationships.find(a=>a.toCharacterId===s.toCharacterId);n?(n.relationshipType=s.relationshipType,n.description=s.description,n.strength=Math.max(n.strength||0,s.strength||0)):r.relationships.push(s)}}return Array.from(i.values())}static resolveCharacterInteractionConflicts(t,e){const i=[...t],s=[],r=[];for(const n of e){const a=this.attemptConflictResolution(n,i);a.success?(s.push(a.action),a.updatedCharacters&&a.updatedCharacters.forEach((o,l)=>{const c=i.findIndex(p=>p.id===o.id);c>=0&&(i[c]=o)})):r.push(n)}return{resolvedCharacters:i,resolutionActions:s,unresolvedConflicts:r}}static attemptConflictResolution(t,e){return t.includes("name conflict")?{success:!0,action:"Resolved name conflict by adding unique suffix"}:t.includes("Relationship conflict")?this.resolveRelationshipConflict(t,e):{success:!1}}static resolveRelationshipConflict(t,e){const i=t.match(/"([^"]+)"/g);if(!i||i.length<2)return{success:!1};const s=i[0].replace(/"/g,""),r=i[1].replace(/"/g,""),n=e.find(c=>c.name===s),a=e.find(c=>c.name===r);if(!n||!a)return{success:!1};const o=n.relationships.find(c=>c.toCharacterId===a.id),l=a.relationships.find(c=>c.toCharacterId===n.id);if(o&&l){const c=(o.strength||0)>=(l.strength||0)?o:l;return o.relationshipType=c.relationshipType,l.relationshipType=this.getReciprocalRelationshipType(c.relationshipType),{success:!0,action:`Resolved relationship conflict by using stronger relationship: ${c.relationshipType}`,updatedCharacters:[n,a]}}return{success:!1}}static getReciprocalRelationshipType(t){return{parent:"child",child:"parent",boss:"subordinate",subordinate:"boss",teacher:"student",student:"teacher"}[t.toLowerCase()]||t}static buildCharacterNetworkGraph(t){const e=t.map(s=>({id:s.id,name:s.name,role:s.role,importance:this.calculateCharacterImportance(s)})),i=[];for(const s of t)for(const r of s.relationships)s.id<r.toCharacterId&&i.push({from:s.id,to:r.toCharacterId,type:r.relationshipType,strength:r.strength||1});return{nodes:e,edges:i}}static calculateCharacterImportance(t){let e=0;switch(t.role){case"protagonist":e+=100;break;case"antagonist":e+=80;break;case"supporting":e+=50;break;case"minor":e+=20;break}return e+=t.relationships.length*5,e+=t.appearances.length*2,e}static analyzeCharacterNetwork(t){const e=t.filter(c=>c.relationships.length===0),i=t.filter(c=>c.relationships.length>10),s=[];for(const c of t)for(const p of c.relationships){const h=t.find(d=>d.id===p.toCharacterId);h&&(h.relationships.find(u=>u.toCharacterId===c.id)||s.push(`Missing reciprocal relationship: ${c.name} -> ${h.name} (${p.relationshipType})`))}const r=t.length,n=t.filter(c=>c.relationships.length>0).length,a=r>0?n/r:0,o=s.length*5,l=Math.max(0,Math.min(100,a*100-o));return{isolatedCharacters:e,overconnectedCharacters:i,relationshipInconsistencies:s,networkHealth:l}}}export{g as C};
